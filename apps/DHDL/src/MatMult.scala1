import dhdl.compiler._
import dhdl.library._
import dhdl.shared._
import scala.util.Random

object MatMultCompiler extends DHDLApplicationCompiler with MatMult 
object MatMultInterpreter extends DHDLApplicationInterpreter with MatMult

trait MatMult extends DHDLApplication {
	def printUsage = {
    println("Usage: matmult")
    exit(-1)
	}
	def matmultTile(tileA: Rep[BRAM[FixPt]], tileB: Rep[BRAM[FixPt]], tileC: Rep[BRAM[FixPt]],
		bm:Int, bn:Int, bp:Int) = {
		val ijCounter = CounterChain(Counter(bm, 1), Counter(bn, 1))
		//TODO: this is sequential
		MetaPipe(1, ijCounter, {case i::j::_ =>
			val accum = Reg[FixPt](0)
			val kCounter = CounterChain(Counter(bp, 1)) 
			Pipe[FixPt](1, kCounter, accum, _+_, {case k::_ =>
				val x = tileA.ld(i*bp+k)
				//TODO: ???
				val y = tileB.ld(k*bn+j)
				x * y
			})
			//TODO:put into pipe
			tileC.st(i*bn+j, accum.value)
		})
	}

  def main() = {
		val bm = 2
		val bn = 2
		val bp = 2
		val sM = 4
		val sN = 4
		val sP = 2
		val sM1 = Seq.fill(sM)(Seq.fill(sP)(Random.nextInt(100)))
		val sM2 = Seq.fill(sP)(Seq.fill(sN)(Random.nextInt(100)))
		println("M1")
		sM1.map{_.mkString(",")}.mkString("\n")
		println("M2")
		sM2.map{_.mkString(",")}.mkString("\n")
		val M3Gold = Seq.tabulate(sM){i =>
			val v1 = sM1(i)
			Seq.tabulate(sN) {j =>
				val v2 = sM2.map(row => row(j))
				v1.zip(v2).map{case (a,b) => a*b}.reduce(_+_)
			}
		}
		println("M3Gold")
		M3Gold.map{_.mkString(",")}.mkString("\n")

		val M = ArgIn[Int](sM).value
		val N = ArgIn[Int](sN).value
		val P = ArgIn[Int](sP).value
		//val M1 = OffChipMem[FixPt]("M1", sM1.map(i => i.toFixPt): _*)
		val M1 = OffChipMem[FixPt]("M1", M.value*P.value)
		//val M2 = OffChipMem[FixPt]("M2", sM2.map(i => i.toFixPt): _*)
		val M2 = OffChipMem[FixPt]("M2", P.value*N.value)
		val M3 = OffChipMem[FixPt]("M3", M.value*N.value)
		val ijkCounter = CounterChain(Counter(M.value, bm), (N.value,bn), (P.value,bp))

		MetaPipe(3, ijkCounter, {case i::j::k::_ => 
			val m1Tile = BRAM[FixPt](bm*bp)
			val m2Tile = BRAM[FixPt](bp*bn)
			Parallel({
				M1.ld(m1Tile, i, k, bm, bp, M.value)
				M2.ld(m2Tile, k, j, bp, bn, P.value)
				()
			})

			Parallel({
				val multTile = BRAM[FixPt](bm*bn)
				matmultTile(m1Tile, m2Tile, multTile, bm, bn, bp)
				val accumTile = BRAM[FixPt](bm*bn)
				M3.ld(accumTile, i, j, bm, bn, M.value)
				()
			})
			()
		})
		val sumTile = BRAM[FixPt](bm*bn)

	}
}
